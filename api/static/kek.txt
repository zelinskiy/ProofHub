{-# LANGUAGE ExistentialQuantification, ScopedTypeVariables #-}

import Data.Typeable
import Data.Maybe

data Thing = forall t. Typeable t => PhysicalThing String t
           | forall t. Typeable t => CollectionOfThings String [t]
           
boiler = PhysicalThing "Boiler" False
thermometer = PhysicalThing "Thermometer" (20 :: Int)
thermostat = CollectionOfThings "Thermostat" [boiler, thermometer]

getTemperature :: Thing -> Int
getTemperature (PhysicalThing "Thermometer" t) = (fromJust (cast t))
getTemperature _ = error "Not a thermometer"

setTemperature :: Thing -> Int -> Thing
setTemperature (PhysicalThing "Thermometer" t) t' = PhysicalThing "Thermometer" t'
setTemperature _ _ = error "Not a thermometer"

controlBoiler :: Thing -> Bool -> Thing
controlBoiler (PhysicalThing "Boiler" power) power' = PhysicalThing "Boiler" power'
controlBoiler _ _ = error "Not a boiler"

boilerOn :: Thing -> Bool
boilerOn (PhysicalThing "Boiler" power) = (fromJust (cast power))
boilerOn _ = error "Not a boiler"

loop :: Thing -> IO Thing
loop (CollectionOfThings "Thermostat" [boiler, thermometer]) = do
  let t :: Int = getTemperature (fromJust (cast thermometer))
  let (b, tm) = (fromJust (cast boiler), fromJust (cast thermometer))
  thermometer' <- if (boilerOn (fromJust (cast boiler)))
                  then return $ setTemperature tm (t + 1)
                  else return $ setTemperature tm (t - 1)
  boiler' <- if (t < 20)
             then do {putStrLn "Heating boiler"; return $ controlBoiler b True}
             else do {putStrLn "Not heating boiler"; return $ controlBoiler b False}
  let thermostat' = CollectionOfThings "Thermostat" [boiler', thermometer']
  loop thermostat'

main :: IO ()
main = loop thermostat >> return ()
